#!/bin/bash
# unilive-builder: Bootable Live Media builder.
# Copyright (C) 2014 Arthur (MingYe) Wang <arthur200126@gmail.com>
# Copyright (C) 2014 Jeff (MingCong) Bai <jeffbaichina@member.fsf.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# The following is a native implementation of RemasterSys... simplified actually, for AOSC OS2 Distros.
# So it works with Debian initrds.
# Also it's intended for further *Spin Editions* to be built easily and legitimately.

# What's Implemented Now?
# 1. A simple interface and routine for mounting build drive and do some clean up.
# 2. Tells the user what to do with configuration files.

# TODOs
# Wrap package manager operations
# Switch operation logging to do_ok "Information" "Process"
# do_ok() defect: unable to get variables' values after $2 is done.
  # Try using eval.

lib=${1:-$(dirname $(readlink -e $0))}
scriptname=unilive-builder

# ISO Boot Check
if ! [ -d ${lib}/example-iso-boot ]; then
  echo -e "example iso root not found.\nGo to github.com/AOSC-Dev/AOSC-InstallKit to get it."
  exit 1
fi

# Prolog...
echo -e "\e[31mHere is something important before you proceed\e[0m"
echo " - Never hack this program unless YOU KNOW WHAT YOU ARE DOING"
echo " - You need about 50% or more space left in your target partition"
echo " - You need about 2-4 GiB of RAM available, the more, the better"
echo " - This can take you all day if you don't have a beefy computer"
echo " - There are things that are not allowed to be preinstalled, like Google Chrome, Adobe Flash Plugin and Firefox"
echo ""
echo ""
read -p "Press any key to get started, whenever you feel comfortable"

# Make sure network is working
echo -e "Please tell me if the network is working \e[36m[INFO]\e[0m"
echo -e "\e[31mIf it's working, press any key to procceed, if not, press Ctrl-C right away to quit\e[0m"
echo 
read -p "Press any key to procceed or use Ctrl-C to quit..."

# Check if the user is running the script with root priviledges.
if [ "$EUID" != "0" ]; then
   echo "This script must be run as root" 1>&2
   exit 1
fi

# Get partition
echo "Please tell me the partition you've put your distro in: " 
read -e -i "/dev/" -p "partition>" partition

do_ok "Create mount directory..." "mkdir /target > /dev/null"

do_ok "umount-ing $partition" "umount -Rf $partition || true"

# Check filesystem type
# Follow-up printf used as workaround.
do_ok "Detect FS type of specified partition=" "fs=$(df -T | grep $partition | awk '{print $2}' 2>/dev/null; printf "$fs")"

if [ "fs" == "fuseblk" ]; then
  echo -e "fuseblk fs detected.              [\e[31mWARN\e[0m]\nPlease enter your real fs name as used in mount and fsck:"
  echo -e "Please also make sure you are using a POSIX-compatible fs\nso anything don't get messed up."
  read -e -p "fs=" -i "$fs" fs
fi

# Not sure why it doesn't work in anyway
# do_ok "Checking specified partition for FS error or corruption..." "fsck.$fs $partition || ignore_command_not_found" || exit 1

# Mount partition to /target
do_ok "mounting partition.." "mount -t fs $partition /target &> /dev/null"

# LSB Information Fill-in
echo -e "Now we need to make sure that you have your /etc/lsb-release file filled in... \e[36m[INFO]\e[0m"
lsbinput
lsbgen > lsb-release.change
vim lsb-release.change
mv lsb-release.change /target/etc/lsb-release
echo -e "/etc/lsb-release filled in... \e[36m[INFO]\e[0m"

# Choose installer to use
# Dnfize!(try to wrap the install)
while (read -e -n 1 -p "Would you like to include an installer in your system(Y/n)" -i "Y" installer); do
echo
case $installer in
  y|Y)
    while (read -e -n 1 -p "Would you like to have a Qt GUI installer?(Y/n)" -i "Y" qt-installer); do
    echo
    installers="aosc-installers"
    case $qt-installer in
      y|Y|yes)
        installers+="aosc-installer-qt"
        break
        ;;
      n|N|no)
        break
        ;;
      *)
        echo "Invalid selection!"
     esac
     ;;
     chroot /target "apt-get install $installers"
     chroot /target "aosc-installer-prepare"
 n|N)
    read -n 1 -e -i "n" -p "Wow, are you sure you want to make a live-only spin?(y/Y)" noinst
    if ([ "$noinst" == "y" ] || [ "$noinst" == "Y"]); then break; fi
 *)
    echo "Invalid selection!"
esac


# Auditing...
echo -e "As the system will be released as a free/libre distro, 
we are now going to remove proprietary software... \e[31m[IMPORTANT]\e[0m"
chroot /target "apt-get purge google-chrome flashplugin-nonfree firefox xulrunner"
# A bug of Google Chrome package...
do_ok "Performing Google Chrome Cleanup..." "rm -rf /opt/google-chrome"

# Clean up distro...
echo -e "We are now going to clean up, but meanwhile,
you will procceed into a temporary shell to pack up the
configuration files for your user... \e[36m[INFO]\e[0m"
echo -e "\e[31mRemember to copy all the necessary files into /etc/skel !!!\n\e[1mNot including your browsing data!!!\e[0m"
echo -e "\e[31mPlease use 'exit' to quit when you are done.\e[0m"
chroot /target
do_ok "Cleaning up target system... \" "(rm -rf /target/home/*
chroot /target useradd -g users live -m 
rm -rf /target/boot/grub/grub.cfg /target/tmp/* /target/var/{tmp,log,spool,cache/fontconfig/*}
chroot /target apt-get clean) >> /tmp/$scriptname.out"
echo -e "Now, set the password of the user... \e[36m[INFO]\e[1m\nNote: Using 'live' as password is recommended.\e[0m"
read -e -p "Password for live:" -i live livepass
do_ok "Setting up live user..." "change_passwd live $livepass"
rm -rf /target/root/.* 
rm -rf /target/root/*
cp -r /target/etc/skel/. /target/root
chroot /target chown -R root /root
echo -e "Setting up root... \e[36m[OK\e[0m"

# Packing...
umount -Rf /target/{dev,proc,sys}
echo "Enter the Squashfs flags you want to use: "
echo "You may want to use: 
-always-use-fragments to sacrifice mechanic medias'performance
for better compression rates.
-Xbcj x86 to make the image smaller(and faster to read
on slow Medias) at the cost of mush longer compression time."
$SQUASHFLAGS="-b 1048576 -comp xz -Xdict-size 100% -Xbcj x86"
read -e -p "mksquashfs target squash" -i "$SQUASHFLAGS" -t 20 || true
# do_ok exception since there is a progress bar
echo -e "Building squashfs file for the distro... This may take some time!!!\e[36m[INFO]\e[0m"
mksquashfs /target/* /target/squash $SQUASHFLAGS
# \r (return) deletes the line above, well actually I am not sure
# how many lines are used by mksquashfs to display the progress bar
echo -e "\r\rBuilding squashfs file for the distro... \e[32m[OK]\e[0m"

# Build ISO
echo -e "You are now required to edit the grub.cfg file for the release... \e[36m[INFO]\e[0m"
do_ok "Updating GRUB configuration..." "mkgrubcfg > /target/iso/boot/grub/grub.cfg && (vi grub.cfg; true) || false"
do_ok "Now building iso for the distro..." "
cp -r /example-iso-boot /target/iso/boot
mv /target/squash /target/iso/
grub-mkrescue -o /target/aosc_os2-custom.iso /target/iso"

# Final phase
echo -e "Now the iso is ready, be ready to share! \e[36m[HURRAY!!!]\e[0m"
# echo -e "LIVE CLEAR [\e[36mNICONICONI\e[0m]"


# Function Includes Start
lsbinput() {
  . /etc/lsb-releaae || true
  . /etc/os-release || true
  echo "Input the following system infos:"
  read -e -p "Distribution Name/ID of your Distro:" -i ${DISTRIB_ID-$ID} DISTRIB_ID
  read -e -p "Version/Release:" -i ${DISTRIB_RELEASE-$VERSION} DISTRIB_RELEASE
  read -e -p "Codename:" -i ${DISTRIB_CODENAME-Misaka} DISTRIB_CODENAME
  read -e -p "Description:" -i ${DISTRIB_DESCRIPTION-$PRETTY_NAME} DISTRIB_DESCRIPTION 
  lsb_release &> /dev/null && read -p "LSB Version:" -i ${LSB_VERSION-4.1} LSB_VERSION
}

# lsbgen > lsb-release.change
lsbgen() {
  echo "# LSB Release information generated by AOSC unilive-builder"
  echo "# Source system $NAME, distro timestamp `date -u +%s`($(LANG=C date -u))."
  # Comment the line if LSB not enabled
  ! [ $LSB_VERSION ] && printf "# "
  for i in LSB_VERSION DISTRIB_{ID,RELEASE,CODENAME,DESCRIPTION}; do
    echo "$i=\"$(eval echo \$$i)\""
  done
}

# mkgrubcfg > grub.cfg at iso
mkgrubcfg() {
  echo -e "# grub.cfg for Live Medias generated by unilive-builder\n# generate-time: $(LANG=C date -u)/$(date -u +%s)"
  # Skeleton
  cat ${lib}/grub.cfg | tail -n +2| sed "s/\(LANG\)/$LANG/g" | sed "s/\(INITRD\)/$(basename $(ls example-iso-boot/initrd*))/g"
  menuentry "$DISTRIB_ID, $DISTRIB_RELEASE \"$DISTRIB_CODENAME\"" loadlive quiet rw rootdelay=5
  menuentry "$DISTRIB_ID, $DISTRIB_RELEASE \"$DISTRIB_CODENAME\" with safe mode graphics" loadlive quiet nomodeset rw rootdelay=5
}

menuentry() {
  echo "memuentry \"$1\" {"
  shift
  echo -e "  $*"
  echo "}"
}

do_ok() {
  printf "$1"
  (eval "$2" 2>>/tmp/${scriptname-$0}) && echo -e "$3[\e[32mOK\e[0m]" || (
    echo -e "$3[\e[31mFAILED\e[0m]"
    read -p "Error occoured. Press any key to continue." -n 1 -t 5 
    echo "Error information available in /tmp/${scriptname-$0}" && return 1
  )
}

ignore_command_not_found() { 
  local _ret=$?
  case _ret in
    127|0)
      return 0
      ;;
    *)
      return $_ret
      ;;
   esac
}

change_password() {
  LANG=C expect << EOF
  spawn chroot /target "passwd $1"
  expect "Enter new UNIX password:"
  send "$2\r"
  expect "Retype new UNIX password:"
  send "$2\r"
  expect eof;
  EOF
  }
  
# -*- vim:fenc=utf-8:shiftwidth=2:softtabstop=2